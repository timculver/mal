# Globals
       # T  Token stack, with first token at the top
       # M  Memory, as an array.
0sm    # m  Next free entry in M.

# q() : exit caller
[q]sq

# R() : rep()
[
  [z0=q          # Until z == 0: push -> T
    ST lax]salax
  LTd;Kx          # Read an expression from T, pushing address
  d;M;Jx         # Print the object at the address
  []p           # print ascii 26 as a signal to flush
]sR

# K[0](type) : read an integer from T into M, return address
[
  lm:M             # M[m] = type
  LT
  lm1+:M           # M[m+1] = number
  lm               # return m
  lm2+sm           # m += 2
]0:K

# K[{1,2}](type) : read a symbol from T into M, return address
[
  0Sn0Sa           # reserve locals
  lm:M             # M[m] = type
  LT               # get next token (string)
  dZsn             # n = string length
  lm2+:M           # M[m+2] = string
  # The symbol is represented by a large number made from the ASCII characters of the symbol.
  # e.g. foo = 707979
  0
  [ln0=q           # Until n == 0:
    100*           #   multiply by 100
    LT+32-         #   + next token - 32
    ln1-sn         #   n -= 1
    lax]salax
  lm1+:M           # M[m+1] = large number
  lm               # return m
  lm3+sm           # m += 3
  Lns@Las@         # restore locals
]d 1:K 2:K

# J[type](address) : print object at M[address]
[ 1+;Mn          ]0:J
[ 2+;Mn          ]1:J
[ ["]n2+;Mn["]n  ]2:J
