# Globals
       # T  Token stack, with first token at the top
       # M  Memory, as an array.
0sm    # m  Next free entry in M.

# q() : exit caller
[q]sq

# R() : rep()
[
  [z0=q          # Until z == 0: push -> T
    ST lax]salax
  LT;Kx          # Read an expression from T, pushing address
  d;M;Jx         # Print the object at the address
  []p           # print ascii 26 as a signal to flush
]sR

# K[0]() : read an integer from T into M, return address
[
  0lm:M            # M[m] = 0
  LT
  lm1+:M           # M[m+1] = number
  lm               # return m
  lm2+sm           # m += 2
]0:K

# K[1]() : read a symbol from T into M, return address
[
  0Sn              # reserve locals
  1lm:M            # M[m] = 1
  LT               # get next token (string)
  dZsn             # n = string length
  lm2+:M           # M[m+2] = string
  # The symbol is represented by a large number made from the ASCII characters of the symbol.
  # e.g. foo = 707979
  0
  [ln0=q           # Until n == 0:
    100*           #   multiply by 100
    LT+32-         #   + next token - 32
    ln1-sn         #   n -= 1
    lax]salax
  lm1+:M           # M[m+1] = large number
  lm               # return m
  lm3+sm           # m += 3
  Lns@             # restore locals
]1:K

# J[type](address) : print object at M[address]
[ 1+;Mn    ]0:J
[ 2+;Mn    ]1:J
