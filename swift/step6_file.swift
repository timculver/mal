//******************************************************************************
// MAL - step 6 - file
//******************************************************************************
// This file is automatically generated from templates/step.swift. Rather than
// editing it directly, it's probably better to edit templates/step.swift and
// regenerate this file. Otherwise, your change might be lost if/when someone
// else performs that process.
//******************************************************************************

import Foundation

// The number of times EVAL has been entered recursively. We keep track of this
// so that we can protect against overrunning the stack.
//
var EVAL_level = 0

// The maximum number of times we let EVAL recurse before throwing an exception.
// Testing puts this at some place between 1800 and 1900. Let's keep it at 500
// for safety's sake.
//
let EVAL_leval_max = 500

// Control whether or not tail-call optimization (TCO) is enabled. We want it
// `true` most of the time, but may disable it for debugging purposes (it's
// easier to get a meaningful backtrace that way).
//
let TCO = true

// Control whether or not we emit debugging statements in EVAL.
//
let DEBUG_EVAL = false

let INDENT_TEMPLATE = "|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|" +
    "----|----|----|----|----|----|----|----|----|----|----|"

let kSymbolArgv             = MalSymbol(symbol: "*ARGV*")
let kSymbolDef              = MalSymbol(symbol: "def!")
let kSymbolDo               = MalSymbol(symbol: "do")
let kSymbolEval             = MalSymbol(symbol: "eval")
let kSymbolFunction         = MalSymbol(symbol: "fn*")
let kSymbolIf               = MalSymbol(symbol: "if")
let kSymbolLet              = MalSymbol(symbol: "let*")

// Class to help control the incrementing and decrementing of EVAL_level. We
// create one of these on entry to EVAL, incrementing the level. When the
// variable goes out of scope, the object is destroyed, decrementing the level.
//
class EVAL_Counter {
    init() {
        ++EVAL_level
    }
    deinit {
        --EVAL_level
    }
}

// Parse the string into an AST.
//
func READ(str: String) -> MalVal {
    return read_str(str)
}

// Perform a simple evaluation of the `ast` object. If it's a symbol,
// dereference it and return its value. If it's a collection, call EVAL on all
// elements (or just the values, in the case of the hashmap). Otherwise, return
// the object unchanged.
//
func eval_ast(ast: MalVal, env: Environment) -> MalVal {
    if is_symbol(ast) {
        let symbol = ast as MalSymbol
        if let val = env.get(symbol) {
            return val
        }
        return MalError(message: "'\(symbol)' not found")    // Specific text needed to match MAL unit tests
    }
    if is_list(ast) {
        let list = ast as MalList
        var result = [MalVal]()
        result.reserveCapacity(list.count)
        for item in list {
            let eval = EVAL(item, env)
            if is_error(eval) { return eval }
            result.append(eval)
        }
        return MalList(array: result)
    }
    if is_vector(ast) {
        let vec = ast as MalVector
        var result = [MalVal]()
        result.reserveCapacity(vec.count)
        for item in vec {
            let eval = EVAL(item, env)
            if is_error(eval) { return eval }
            result.append(eval)
        }
        return MalVector(array: result)
    }
    if is_hashmap(ast) {
        let hash = ast as MalHashMap
        var result = [MalVal]()
        result.reserveCapacity(hash.count * 2)
        for (k, v) in hash {
            let new_v = EVAL(v, env)
            if is_error(new_v) { return new_v }
            result.append(k)
            result.append(new_v)
        }
        return MalHashMap(array: result)
    }
    return ast
}

// Walk the AST and completely evaluate it, handling macro expansions, special
// forms and function calls.
//
func EVAL(var ast: MalVal, var env: Environment) -> MalVal {
    var x = EVAL_Counter()
    if EVAL_level > EVAL_leval_max {
        return MalError(message: "Recursing too many levels (> \(EVAL_leval_max))")
    }

    let indent = INDENT_TEMPLATE.substringToIndex(
        advance(INDENT_TEMPLATE.startIndex, EVAL_level, INDENT_TEMPLATE.endIndex))

    while true {
        if is_error(ast) { return ast }
        if DEBUG_EVAL { println("\(indent)>   \(ast)") }

        // Special handling if it's a list.

        if is_list(ast) {
            var list = ast as MalList
            if DEBUG_EVAL { println("\(indent)>.  \(list)") }

            if list.isEmpty {
                return ast
            }

            let arg1 = list.first()
            if is_symbol(arg1) {
                let fn_symbol = arg1 as MalSymbol

                // Check for special forms, where we want to check the operation
                // before evaluating all of the parameters.

                if fn_symbol == kSymbolDef {
                    if list.count != 3 {
                        return MalError(message: "expected 2 arguments to def!, got \(list.count - 1)")
                    }
                    let arg1 = list[1]
                    let arg2 = list[2]
                    if !is_symbol(arg1) {
                        return MalError(message: "expected symbol for first argument to def!")
                    }
                    let sym = arg1 as MalSymbol
                    let value = EVAL(arg2, env)
                    if is_error(value) { return value }
                    return env.set(sym, value)
                } else if fn_symbol == kSymbolLet {
                    if list.count != 3 {
                        return MalError(message: "expected 2 arguments to let*, got \(list.count - 1)")
                    }
                    let arg1 = list[1]
                    let arg2 = list[2]
                    if !is_sequence(arg1) {
                        return MalError(message: "expected list for first argument to let*")
                    }
                    let bindings = arg1 as MalSequence
                    if bindings.count % 2 == 1 {
                        return MalError(message: "expected even number of elements in bindings to let*, got \(bindings.count)")
                    }
                    var new_env = Environment(outer: env)
                    for var index = 0; index < bindings.count; index += 2 {
                        let binding_name = bindings[index]
                        let binding_value = bindings[index + 1]

                        if !is_symbol(binding_name) {
                            return MalError(message: "expected symbol for first element in binding pair")
                        }
                        let binding_symbol = binding_name as MalSymbol
                        let evaluated_value = EVAL(binding_value, new_env)
                        if is_error(evaluated_value) { return evaluated_value }
                        new_env.set(binding_symbol, evaluated_value)
                    }
                    if TCO {
                        env = new_env
                        ast = arg2
                        continue
                    }
                    return EVAL(arg2, new_env)
                } else if fn_symbol == kSymbolDo {
                    if TCO {
                        let eval = eval_ast(MalList(slice: list[1..<list.count-1]), env)
                        if is_error(eval) { return eval }
                        ast = list.last()
                        continue
                    }

                    let evaluated_ast = eval_ast(list.rest(), env)
                    if is_error(evaluated_ast) { return evaluated_ast }
                    let evaluated_seq = evaluated_ast as MalSequence
                    return evaluated_seq.last()
                } else if fn_symbol == kSymbolIf {
                    if list.count < 3 {
                        return MalError(message: "expected at least 2 arguments to if, got \(list.count - 1)")
                    }
                    let cond_result = EVAL(list[1], env)
                    var new_ast = MalVal()
                    if is_truthy(cond_result) {
                        new_ast = list[2]
                    } else if list.count == 4 {
                        new_ast = list[3]
                    } else {
                        return MalNil()
                    }
                    if TCO {
                        ast = new_ast
                        continue
                    }
                    return EVAL(new_ast, env)
                } else if fn_symbol == kSymbolFunction {
                    if list.count != 3 {
                        return MalError(message: "expected 2 arguments to fn*, got \(list.count - 1)")
                    }
                    if !is_sequence(list[1]) {
                        return MalError(message: "expected list or vector for first argument to fn*")
                    }
                    return MalClosure(eval: EVAL, args:list[1] as MalSequence, body:list[2], env:env)
                }
            }

            // Standard list to be applied. Evaluate all the elements first.

            let eval = eval_ast(ast, env)
            if is_error(eval) { return eval }

            // The result had better be a list and better be non-empty.

            let eval_list = eval as MalList
            if eval_list.isEmpty {
                return eval_list
            }

            if DEBUG_EVAL { println("\(indent)>>  \(eval)") }

            // Get the first element of the list and execute it.

            let first = eval_list.first()
            let rest = eval_list.rest()

            if is_builtin(first) {
                let fn = first as MalBuiltin
                let answer = fn.apply(rest)
                if DEBUG_EVAL { println("\(indent)>>> \(answer)") }
                return answer
            } else if is_closure(first) {
                let fn = first as MalClosure
                var new_env = Environment(outer: fn.env)
                let result = new_env.set_bindings(fn.args, with_exprs:rest)
                if is_error(result) { return result }
                if TCO {
                    env = new_env
                    ast = fn.body
                    continue
                }
                let answer = EVAL(fn.body, new_env)
                if DEBUG_EVAL { println("\(indent)>>> \(answer)") }
                return answer
            }

            // The first element wasn't a function to be executed. Return an
            // error saying so.

            return MalError(message: "first list item does not evaluate to a function: \(first)")
        }

        // Not a list -- just evaluate and return.

        let answer = eval_ast(ast, env)
        if DEBUG_EVAL { println("\(indent)>>> \(answer)") }
        return answer
    }
}

// Convert the value into a human-readable string for printing.
//
func PRINT(exp: MalVal) -> String? {
    if is_error(exp) { return nil }
    return pr_str(exp, true)
}

// Perform the READ and EVAL steps. Useful for when you don't care about the
// printable result.
//
func RE(text: String, env: Environment) -> MalVal? {
    if text.isEmpty { return nil }
    let ast = READ(text)
    if is_error(ast) {
        println("Error parsing input: \(ast)")
        return nil
    }
    let exp = EVAL(ast, env)
    if is_error(exp) {
        println("Error evaluating input: \(exp)")
        return nil
    }
    return exp
}

// Perform the full READ/EVAL/PRINT, returning a printable string.
//
func REP(text: String, env: Environment) -> String? {
    let exp = RE(text, env)
    if exp == nil { return nil }
    return PRINT(exp!)
}

// Perform the full REPL.
//
func REPL(env: Environment) {
    while true {
        if let text = _readline("user> ") {
            if let output = REP(text, env) {
                println("\(output)")
            }
        } else {
            println()
            break
        }
    }
}

// Process any command line arguments. Any trailing arguments are incorporated
// into the environment. Any argument immediately after the process name is
// taken as a script to execute. If one exists, it is executed in lieu of
// running the REPL.
//
func process_command_line(args:[String], env:Environment) -> Bool {
    var argv = MalList()
    if args.count > 2 {
        let args1 = args[2..<args.count]
        let args2 = args1.map { MalString(unescaped: $0) as MalVal }
        let args3 = [MalVal](args2)
        argv = MalList(array: args3)
    }
    env.set(kSymbolArgv, argv)

    if args.count > 1 {
        RE("(load-file \"\(args[1])\")", env)
        return false
    }

    return true
}

func main() {
    var env = Environment(outer: nil)

    load_history_file()
    load_builtins(env)

    RE("(def! not (fn* (a) (if a false true)))", env)
    RE("(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \")\")))))", env)

    env.set(kSymbolEval, MalBuiltin(function: {
         unwrap($0) {
            (ast:MalVal) -> MalVal in
            EVAL(ast, env)
         }
    }))

    if process_command_line(Process.arguments, env) {
        REPL(env)
    }

    save_history_file()
}
